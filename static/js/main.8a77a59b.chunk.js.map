{"version":3,"sources":["image/logo.png","reducers/github.js","reducers/index.js","components/DataTypes.js","components/sections/Colors.js","scripts/GithubFetcher.js","components/sections/Repository.js","components/sections/ChartOptions.js","components/sections/Star.js","components/sections/Fork.js","components/sections/Commit.js","components/sections/Release.js","components/sections/Issues.js","components/sections/PullRequests.js","components/DataSection.js","components/GithubStatistics.js","actions/github.js","components/App.js","serviceWorker.js","index.js"],"names":["module","exports","INITIAL_STATE","repoData","repoStats","starData","starStats","forkData","forkStats","releaseData","releaseStats","githubApiToken","github","state","action","type","payload","data","Object","assign","stats","reducers","combineReducers","REPO","STAR","FORK","COMMIT","RELEASE","ISSUES","PULLREQUESTS","getProgress","c","t","Math","floor","GithubFetcher","token","searchRepository","input","onResult","a","variables","query","formattedData","gqlClient","request","search","nodes","forEach","repo","push","nameWithOwner","fetchRepositoryData","owner","name","onUpdate","onFinish","onProgress","shouldAbort","repository","createdAt","primaryLanguage","pushedAt","watcherCount","watchers","totalCount","fetchStargazerData","preparationVariables","preparationQuery","Map","pageIndex","totalToFetch","maxIncrement","numberFetched","previousEndCursor","hasNextPage","preparationData","stargazers","handleEdge","edge","date","Date","starredAt","slice","getTime","has","set","get","edges","pageInfo","endCursor","liveUpdate","pagesPerUpdate","total","fetchForkData","forks","handleNode","node","fetchRequestsData","pullRequests","fetchIssuesData","issues","fetchCommitData","defaultBranchRef","target","history","headRefOid","oid","since","committedDate","setFullYear","getFullYear","toISOString","object","fetchReleaseData","totalDownloads","releases","releaseAssets","asset","id","updatedAt","contentType","downloadCount","totalAssets","tagName","this","GraphQLClient","headers","Authorization","Repository","_render","props","ready","Array","from","entries","map","pair","index","dateSinceCreated","now","valueOf","key","color","COLORS","align","justify","className","title","value","toDateString","moment","fromNow","prefix","React","Component","text","undefined","legend","itemStyle","fontWeight","colors","tooltip","shadow","split","credits","enabled","Star","_renderStatistics","averagePerDay","precision","_renderCharts","chart","values","includes","highcharts","Highcharts","options","OPTIONS","events","selection","event","resetSelection","setState","arr","cloneMap","min","xAxis","max","resetData","zoomType","tickColor","yAxis","gridLineWidth","series","dataArray","height","document","getElementById","offsetHeight","backgroundColor","linearGradient","stops","plotOptions","lineWidth","lineColor","isReset","nextProps","loading","obj","create","k","v","JSON","parse","stringify","tmpMap","keys","initial","formatter","increment","cumulativeCount","Fork","Commit","reverse","Release","averageDownloadsPerDay","columns","dataSource","pagination","dataIndex","render","time","format","arrayObj","sort","b","DataSection","_fetch","repos","slashIndex","indexOf","fetchCall","_getAllProgress","progress","reduce","size","_renderUpdateAllButton","icon","disabled","length","onClick","_renderRepoTags","visible","style","display","percent","showInfo","strokeWidth","width","checked","onChange","_renderBody","body","min_height","refs","fetcher","TYPES","fontSize","info","Issues","PullRequests","console","log","prevProps","deleteRepo","delete","filter","ref","content","placement","marginLeft","connect","GithubStatistics","splice","localStorage","setItem","addRepo","message","error","_renderTags","closable","onClose","rel","href","_renderHeaderInput","testingRepo","suggestions","hintMessage","inputEmpty","repoExisted","Fragment","placeholder","defaultActiveFirstOption","onSearch","notFoundContent","showArrow","filterOption","showSearch","Option","updateState","_","debounce","leading","trailing","bind","GetRequest","getItem","url","window","location","theRequest","substr","i","src","frameBorder","scrolling","logo","alt","bounds","offsetTop","Link","padding","dispatch","App","Boolean","hostname","match","store","createStore","ReactDOM","navigator","serviceWorker","then","registration","unregister"],"mappings":"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","file":"static/js/main.8a77a59b.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.09e6b94d.png\";","const INITIAL_STATE = {\n  repoData: [],\n  repoStats: {},\n\n  starData: [],\n  starStats: {},\n\n  forkData: [],\n  forkStats: {},\n\n  releaseData: [],\n  releaseStats: {},\n\n  githubApiToken: '05c1acf261f6b223411c73d8b71cb1a30ce9186a',\n\n}\n\nconst github = (state = INITIAL_STATE, action) => {\n  const { type, payload } = action\n  switch (type) {\n    case 'UPDATE_STATE':\n      return {\n        ...state,\n        ...{[payload.state]: payload.data}\n      }\n    case 'UPDATE_STATS_FIELD':\n      return Object.assign({}, state, {\n        [payload.state] : {\n          ...state[payload.state],\n          ...payload.stats\n        }\n      })\n    default:\n      return state\n  }\n}\n\nexport default github","import { combineReducers } from 'redux'\n\nimport github from './github'\n\nconst reducers = combineReducers({\n  github: github,\n})\n\nexport default reducers","/**\n * Keys are used for reference\n * Values are used for displaying and passing\n */\n\nexport default {\n  REPO: 'Repository',\n  STAR: 'Star',\n  FORK: 'Fork',\n  COMMIT: 'Commit',\n  RELEASE: 'Release',\n  ISSUES: 'Issues',\n  PULLREQUESTS: 'Pull Requests',\n}","export default [\n  '#A2B449',\n  '#E89A41',\n  '#9EABCD',\n  '#56BABD',\n  '#D79AB3',\n  '#E6978A',\n  '#5EBE85',\n]","import {  } from 'graphql'\nimport { GraphQLClient } from 'graphql-request'\n\nconst getProgress = (c, t) => t === 0 ? 100 : Math.floor(c / t * 100)\n\nclass GithubFetcher {\n\n  constructor(token) {\n    const endpoint = 'https://api.github.com/graphql'\n\n    this.gqlClient = new GraphQLClient(\n      endpoint,\n      {\n        headers: {\n          Authorization: 'bearer ' + token,\n        }\n      }\n    )\n\n    // configurations\n    this.liveUpdate = false\n    this.pagesPerUpdate = 20\n  }\n\n  /**\n   * test if the repository exists\n   * @param owner owner of the repository\n   * @param name of the repository\n   * @param onResult (@param result) function that will be called when test finishes\n   * @return false if not exist, true otherwise\n   */\n  // testRepository = async (owner, name, onResult) => {\n  //   const variables = {\n  //     owner: owner,\n  //     name: name,\n  //   }\n\n  //   const query = /* GraphQL */ `\n  //     query getRepository($owner: String!, $name: String!){\n  //       repository(owner: $owner, name: $name) {\n  //         id\n  //       }\n  //     }\n  //   `\n\n  //   try {\n  //     await this.gqlClient.request(query, variables)\n  //   } catch (error) {\n  //     if (onResult) {\n  //       onResult(false)\n  //     }\n  //     return false\n  //   }\n\n  //   if (onResult) onResult(true)\n  //   return true\n  // }\n\n  /**\n   * suggest possible repositories based on current input\n   * @param onResult (@param result) function that will be called when search finishes\n   */\n  searchRepository = async (input, onResult) => {\n    const variables = {\n      query: input,\n    }\n\n    const query = /* GraphQL */ `\n      query searchRepository($query: String!){\n        search(query: $query, first: 5, type: REPOSITORY) {\n          codeCount\n          nodes {\n            ...on Repository {\n              nameWithOwner\n            }\n          }\n        }\n      }\n    `\n    let formattedData = []\n\n    const data = await this.gqlClient.request(query, variables)\n\n    data.search.nodes.forEach(repo => formattedData.push(repo.nameWithOwner))\n\n    if (onResult) onResult(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchRepositoryData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRepository($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          nameWithOwner\n          createdAt\n          primaryLanguage {\n            name\n          }\n          pushedAt\n          watchers(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n\n    // update progress tracking\n    if (onProgress) onProgress(10)\n\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n\n    const formattedData = {\n      name: data.repository.nameWithOwner,\n      createdAt: data.repository.createdAt,\n      primaryLanguage: data.repository.primaryLanguage.name,\n      pushedAt: data.repository.pushedAt,\n      watcherCount: data.repository.watchers.totalCount,\n    }\n\n    // update progress tracking\n    if (onProgress) onProgress(100)\n\n    if (onFinish) onFinish(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchStargazerData = async (owner, name, onUpdate = () => {}, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareStargazers($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          stargazers(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getStargazers($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          stargazers(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            edges {\n              starredAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.stargazers.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n    const handleEdge = edge => {\n      const date = new Date(edge.starredAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.stargazers.edges.forEach(handleEdge)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.stargazers.pageInfo.endCursor\n      hasNextPage = data.repository.stargazers.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch fork data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchForkData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          forks(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          forks(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.forks.totalCount\n    const createdAt = preparationData.repository.createdAt\n    \n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.forks.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.forks.pageInfo.endCursor\n      hasNextPage = data.repository.forks.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n * fetch repository low-level data\n * @param owner owner of the repository\n * @param name name of the repository\n * @param onUpdate (data) function that will be called when a new data update is avaiable\n * @param onFinish (stats) function that will be called when fetching is finished\n * @param onProgress (progress) function that will be called when progress is updated\n * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n * @returns Object that contains statistics\n */\n  fetchRequestsData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          pullRequests(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          pullRequests(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.pullRequests.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0, 10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.pullRequests.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.pullRequests.pageInfo.endCursor\n      hasNextPage = data.repository.pullRequests.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n * fetch repository low-level data\n * @param owner owner of the repository\n * @param name name of the repository\n * @param onUpdate (data) function that will be called when a new data update is avaiable\n * @param onFinish (stats) function that will be called when fetching is finished\n * @param onProgress (progress) function that will be called when progress is updated\n * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n * @returns Object that contains statistics\n */\n  fetchIssuesData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          issues(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          issues(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.issues.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0, 10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.issues.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.issues.pageInfo.endCursor\n      hasNextPage = data.repository.issues.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchCommitData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareCommits($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n          defaultBranchRef {\n            # name\n            target {\n              ... on Commit {\n                oid\n                committedDate\n                history {\n                  totalCount\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getCommits($owner: String!, $name: String!, $previousEndCursor: String, $oid: GitObjectID!, $since: GitTimestamp!){\n        repository(owner: $owner, name: $name) {\n          object(oid: $oid) {\n            ... on Commit {\n              history(first: 100, after: $previousEndCursor, since: $since ) {\n                totalCount\n                pageInfo {\n                  endCursor\n                  hasNextPage\n                }\n                nodes {\n                  committedDate\n                  # message\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let numberFetched = 0\n    let maxIncrement = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.defaultBranchRef.target.history.totalCount\n    const headRefOid = preparationData.repository.defaultBranchRef.target.oid\n    const since = new Date(new Date(preparationData.repository.defaultBranchRef.target.committedDate)\n      .setFullYear(new Date(preparationData.repository.defaultBranchRef.target.committedDate).getFullYear() - 1))\n      .toISOString()\n\n    const handleNode = node => {\n      const date = new Date(node.committedDate.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        oid: headRefOid,\n        since: since,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      totalToFetch = data.repository.object.history.totalCount\n      data.repository.object.history.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.object.history.pageInfo.endCursor\n      hasNextPage = data.repository.object.history.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt: since,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch release data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchReleaseData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRelease($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          releases(first: 1, orderBy:{field:CREATED_AT,direction: DESC}) {\n            totalCount\n            nodes {\n              name\n              tagName\n              createdAt\n              releaseAssets (first: 20) {\n                totalCount\n                nodes {\n                  id\n                  name\n                  updatedAt\n                  contentType\n                  createdAt\n                  downloadCount\n                  \n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = []\n    let totalToFetch = 0\n    let numberFetched = 0\n    let totalDownloads = 0\n\n    // Preparation query\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n\n    if (data.repository.releases.totalCount !== 0) {\n      // from preparation\n      totalToFetch = data.repository.releases.nodes[0].releaseAssets.totalCount\n\n      // get stats of each asset\n      data.repository.releases.nodes[0].releaseAssets.nodes.forEach(asset => {\n        formattedData.push({\n          id: asset.id,\n          name: asset.name,\n          updatedAt: asset.updatedAt,\n          contentType: asset.contentType,\n          createdAt: asset.createdAt,\n          downloadCount: asset.downloadCount,\n        })\n\n        totalDownloads += asset.downloadCount\n\n        numberFetched += 1\n        if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n      })\n\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n        name: data.repository.releases.nodes[0].name,\n        tagName: data.repository.releases.nodes[0].tagName,\n        createdAt: data.repository.releases.nodes[0].createdAt\n      })\n    } else {\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n      })\n    }\n\n    return formattedData\n  }\n}\n\nexport default GithubFetcher","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Repository extends React.Component {\n\n  _render = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { name, createdAt, primaryLanguage, pushedAt, watcherCount } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n\n            return (\n              <div key={`repo-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Repository\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Date created\" value={new Date(createdAt).toDateString()} />                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Days since created\" value={dateSinceCreated} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Primary language\" value={primaryLanguage} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Last push at\" value={moment(pushedAt).fromNow()} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Watchers\" prefix={<Icon type=\"eye\"/>} value={watcherCount} />\n                  </span>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nRepository.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Repository","/**\n * Common highchart options shared by\n * most of the charts\n */\n\nimport COLORS from './Colors'\n\nexport default {\n  title: {\n    text: undefined,\n  },\n  // xAxis: {\n  //   type: 'datetime',\n  // },\n  legend: {\n    itemStyle: {\n      color: 'rgba(0, 0, 0, 0.85)',\n      fontWeight: '300'\n    }\n  },\n  colors: COLORS,\n  tooltip: {\n    shadow: false,\n    split: true,\n  },\n  credits: {\n    enabled: false,\n  },\n}","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Star extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // star total data, index 0\n    let total = { name: repo, data: [] }\n    // star  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n    \n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n  cloneMap(map) {\n    let obj = Object.create(null);\n    for (let [k, v] of map) {\n      obj[k] = v;\n    }\n    obj = JSON.parse(JSON.stringify(obj));\n    let tmpMap = new Map();\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k]);\n    }\n    return tmpMap;\n  }\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index-1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial          \n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n        {Array.from(stats.entries()).map((\n          (pair, index) => {\n            if (ready.get(pair[0])) {\n              const { total, maxIncrement, createdAt } = pair[1]\n              const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24 * 60 * 60 * 1000))\n              const averagePerDay = total / dateSinceCreated\n              return (\n                <div key={`star-statistics-${pair[0]}`}>\n                  <Row>\n                    <Tag color={COLORS[index]}>\n                      {pair[0]}\n                    </Tag>\n                    <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Total stars\" value={total} prefix={<Icon type=\"star\" />} />\n                      </span>\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Avg. stars/day\" value={averagePerDay} precision={2} />\n                      </span>\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Max. stars/day\" value={maxIncrement} />\n                      </span>\n                    </Row>\n                  </Row>\n                </div>\n              )\n            }\n            return false\n          }\n        ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready, chart, type } = this.props\n    if (!Array.from(ready.values()).includes(true)) return\n    return (\n      <>\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            xAxis: {\n              type: 'datetime',\n              tickColor: \"#ffffff\",\n            },\n            yAxis: {\n              gridLineWidth: 0.5,\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              height: document.getElementById(type).offsetHeight - 162,\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              backgroundColor: {\n                linearGradient: [0, 21, 41, 0],\n                stops: [\n                  [0, 'rgb(00, 21, 41)'],\n                ]\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            plotOptions: {\n              series: {\n                lineWidth: 4\n              }\n            },\n            xAxis: {\n              type: 'datetime',\n              lineColor: [0, 21, 41],\n              tickColor: \"#ffffff\",\n            },\n            yAxis: {\n              gridLineWidth: 0.5,\n              lineColor: [0, 21, 41, 0],\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              type: 'line',\n              zoomType: 'x',\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'star increment/day',\n              },\n            },\n            series: Array.from(data.values()).map(dataArray => dataArray[1]),\n          }}\n        />}\n      </>\n    )\n  }\n\n  // _renderLines = (dataIndex) => {\n  //   const { data, ready } = this.props\n  //   const dataReady = Array.from(ready.values())\n  //   console.log(\"Lines are rendered\")\n  //   return Array.from(data.values()).map((dataArray, index) => (\n  //     dataReady[index]\n  //       ?\n  //       <Line\n  //         type=\"monotone\"\n  //         key={`star-chart-total-${dataArray[dataIndex].name}`}\n  //         data={dataArray[dataIndex].data}\n  //         dataKey=\"value\"\n  //         name={dataArray[dataIndex].name}\n  //         stroke={COLORS[index]}\n  //         dot={false}\n  //       />\n  //       :\n  //     <></>\n  //   ))\n  // }\n\n  // _renderCharts = () => {\n  //   const { ready } = this.props\n\n  //   if (!Array.from(ready.values()).includes(true)) return\n\n  //   return (\n  //     <>\n  //     <Row>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'total stars', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(0)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'daily increment', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(1)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //     </Row>\n  //     </>\n  //   )\n  // }\n\n  render() {\n    return (\n      <>\n        {this._renderStatistics()}\n        {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nStar.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Star","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // fprk total data, index 0\n    let total = { name: repo, data: [] }\n    // fork  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total forks\" value={total} prefix={<Icon type=\"fork\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. forks/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. forks/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready, chart, type } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'total forks',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              height: document.getElementById(type).offsetHeight - 162,\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              backgroundColor: {\n                linearGradient: [0, 21, 41, 0],\n                stops: [\n                  [0, 'rgb(00, 21, 41)'],\n                ]\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            plotOptions: {\n              series: {\n                lineWidth: 4\n              }\n            },\n            xAxis: {\n              type: 'datetime',\n              lineColor: [0, 21, 41],\n              tickColor: \"#ffffff\",\n            },\n            yAxis: {\n              gridLineWidth: 0.5,\n              lineColor: [0, 21, 41, 0],\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              type: 'column',\n              zoomType: 'x',\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'fork increment/day',\n              },\n            },\n            series: Array.from(data.values()).map(dataArray => dataArray[1]),\n          }}\n        />}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Commit extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // commit total data, index 0\n    let total = { name: repo, data: [] }\n    // commit  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n\n    // traversal backwards\n    Array.from(data.entries()).slice().reverse().forEach(\n      pair => {\n        cumulativeCount += pair[1]\n        total.data.push([pair[0], cumulativeCount])\n        increment.data.push([pair[0], pair[1]])\n      }\n    )\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total commits\" value={total} prefix={<Icon type=\"history\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. commits/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. commits/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready, chart, type} = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'total commits',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              height: document.getElementById(type).offsetHeight - 162,\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              backgroundColor: {\n                linearGradient: [0, 21, 41, 0],\n                stops: [\n                  [0, 'rgb(00, 21, 41)'],\n                ]\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            plotOptions: {\n              series: {\n                lineWidth: 4\n              }\n            },\n            xAxis: {\n              type: 'datetime',\n              lineColor: [0, 21, 41],\n              tickColor: \"#ffffff\",\n            },\n            yAxis: {\n              gridLineWidth: 0.5,\n              lineColor: [0, 21, 41, 0],\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n        {!chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              type: 'column',\n              zoomType: 'x',\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'commit increment/day',\n              },\n            },\n            series: Array.from(data.values()).map(dataArray => dataArray[1]),\n          }}\n        />}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nCommit.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Commit","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag, Table } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Release extends React.Component {\n\n  _render = () => {\n    const { stats, data, ready } = this.props\n\n    return (\n      <>\n      {Array.from(ready.entries()).map((\n        (pair, index) => {\n          if (pair[1]) { // ready\n            const { totalAssets, name, tagName, createdAt, totalDownloads } = stats.get(pair[0])\n\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averageDownloadsPerDay = totalDownloads / dateSinceCreated\n\n            return (\n              <div key={`release-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release tag\" value={tagName} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release name\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total assets\" value={totalAssets} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total asset downlaods\" value={totalDownloads} prefix={<Icon type=\"download\"/>} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Avg. downloads/day\" value={averageDownloadsPerDay} precision={2} />\n                  </span>\n                </Row>\n                <Row>\n                  <Table columns={columns} dataSource={data.get(pair[0])} pagination={false}/>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nconst columns = [\n  {\n    title: 'Asset',\n    dataIndex: 'name',\n    key: 'name',\n  },\n  {\n    title: 'Content type',\n    dataIndex: 'contentType',\n    key: 'contentType',\n  },\n  {\n    title: 'Downloads',\n    dataIndex: 'downloadCount',\n    key: 'downloadCount',\n  },\n  {\n    title: 'Created at',\n    dataIndex: 'createdAt',\n    key: 'createdAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n  {\n    title: 'Updated at',\n    dataIndex: 'updatedAt',\n    key: 'updatedAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n\n]\n\n\nRelease.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Release","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n\n  static formatter = (repo, data) => {\n    // issues total data, index 0\n    let total = { name: repo, data: [] }\n    // issues  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n    let cumulativeCount = 0\n    let arrayObj = Array.from(data);\n    arrayObj.sort(function (a, b) {\n      return a[0] - b[0];\n    })\n    arrayObj.forEach((value, key) => {\n      cumulativeCount += value[1]\n      total.data.push([value[0], cumulativeCount])\n      \n      increment.data.push([value[0], value])\n    })\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total issues\" value={total} prefix={<Icon type=\"info-circle\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. issues/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. issues/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total issues',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // fprk total data, index 0\n    let total = { name: repo, data: [] }\n    // fork  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total pull requests\" value={total} prefix={<Icon type=\"pull-request\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. pull requests/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. pull requests/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready, chart, type } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n        {!chart &&<HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total pull requests',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n        />}\n        {chart && <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              height: document.getElementById(type).offsetHeight - 162,\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min;\n                    var max = event.xAxis[0].max;\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              backgroundColor: {\n                linearGradient: [0, 21, 41, 0],\n                stops: [\n                  [0, 'rgb(00, 21, 41)'],\n                ]\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            plotOptions: {\n              series: {\n                lineWidth: 4\n              }\n            },\n            xAxis: {\n              type: 'datetime',\n              lineColor: [0, 21, 41],\n              tickColor: \"#ffffff\",\n            },\n            yAxis: {\n              gridLineWidth: 0.5,\n              lineColor: [0, 21, 41, 0],\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />}\n      {!chart && <HighchartsReact\n        highcharts={Highcharts}\n        options={{\n          ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n// import _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport '../css/DataSection.css'\n\nimport { Progress, Button, Row, Icon, Tag, Popover } from 'antd'\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport Repository from './sections/Repository'\nimport Star from './sections/Star'\nimport Fork from './sections/Fork'\nimport Commit from './sections/Commit'\nimport Release from './sections/Release'\nimport Issues from './sections/Issues'\nimport PullRequests from './sections/PullRequests'\n\nclass DataSection extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      progress: new Map(),\n      data: new Map(),\n      stats: new Map(),\n      visible: new Map(),\n      ready: new Map(),\n      loading: false,\n    }\n\n    const { githubApiToken, type, chart } = this.props\n\n    this.fetcher = new GithubFetcher(githubApiToken)\n\n    switch (type) {\n      case TYPES.REPO:\n        this.icon = <Icon type=\"book\" style={{ fontSize: '24px', color: chart ?'#ffffff':'#333333' }} />\n        this.body = Repository\n        this.fetchCall = this.fetcher.fetchRepositoryData\n        break\n      case TYPES.STAR:\n        this.info = 'Star trend data are huge, they might take minutes to load.'\n        this.icon = <Icon type=\"star\" style={{ fontSize: '24px', color: chart ?'#ffffff': '#ffb900' }} />\n        this.body = Star\n        this.fetchCall = this.fetcher.fetchStargazerData\n        break\n      case TYPES.FORK:\n        this.icon = <Icon type=\"fork\" style={{ fontSize: '24px', color: chart ?'#ffffff': '#333333' }} />\n        this.body = Fork\n        this.fetchCall = this.fetcher.fetchForkData\n        break\n      case TYPES.COMMIT:\n        this.info = 'Because of the API restriction, only commits in a recent year will be loaded.'\n        this.icon = <Icon type=\"history\" style={{ fontSize: '24px', color: chart ?'#ffffff': '#333333' }} />\n        this.body = Commit\n        this.fetchCall = this.fetcher.fetchCommitData\n        break\n      case TYPES.RELEASE:\n        this.icon = <Icon type=\"tag\" style={{ fontSize: '24px', color: chart ?'#ffffff': '#333333' }} />\n        this.body = Release\n        this.fetchCall = this.fetcher.fetchReleaseData\n        break\n      case TYPES.ISSUES:\n        this.icon = <Icon type=\"info-circle\" style={{ fontSize: '24px', color: chart ?'#ffffff': '#333333' }} />\n        this.body = Issues\n        this.fetchCall = this.fetcher.fetchIssuesData\n        break\n      case TYPES.PULLREQUESTS:\n        this.icon = <Icon type=\"pull-request\" style={{ fontSize: '24px', color: chart ? '#ffffff' : '#333333' }} />\n        this.body = PullRequests\n        this.fetchCall = this.fetcher.fetchRequestsData\n        break\n      default:\n        console.log('TYPE DOESNOT EXIST')\n        return 'ERROR'\n    }\n\n    // data formatter\n    this.formatter = this.body.formatter\n  }\n  componentDidMount() {\n    const { repos, chart } = this.props\n    if (chart==1) {\n      this.setState({ loading: true })\n      if (this._getAllProgress() === 100 && chart) { // re-fetch all\n        repos.forEach(repo => this._fetch(repo))\n      }\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const { deleteRepo, repos } = this.props\n    const { data, stats, progress, visible, loading, ready } = this.state\n\n    // delete repo out\n    if (deleteRepo !== prevProps.deleteRepo && deleteRepo !== '') {\n      data.delete(deleteRepo)\n      stats.delete(deleteRepo)\n      progress.delete(deleteRepo)\n      ready.delete(deleteRepo)\n      visible.delete(deleteRepo)\n      this.setState({ data, stats, progress, ready, visible, loading: this._getAllProgress() !== 100 && loading && repos.length !== 0 })\n    }\n\n    // new repo in\n    if (prevProps.repos !== repos && deleteRepo === '') {\n      const newRepo = repos.filter(repo => !prevProps.repos.includes(repo))\n      newRepo.forEach(repo => {\n        data.set(repo, {})\n        stats.set(repo, {})\n        progress.set(repo, 0)\n        ready.set(repo, false)\n        visible.set(repo, true)\n        this.setState({ data, stats, progress, ready, visible })\n        if (loading) {\n          this._fetch(repo)\n        }\n      })\n    }\n  }\n\n  /**\n   * fetching from a specific repository\n   * for a specific data type from DataTypes.js\n   * @param repo repo to fectch\n   * @returns exit status string\n   */\n  _fetch = repo => {\n    const { repos } = this.props\n    const slashIndex = repo.indexOf('/')\n    const owner = repo.slice(0, slashIndex)\n    const name = repo.slice(slashIndex + 1)\n\n    const onUpdate = data => {\n      if(this.state.data.has(repo)) {\n        this.state.data.set(\n          repo,\n          this.formatter ? this.formatter(repo, data) : data,\n        )\n        this.setState({ data: this.state.data })\n      }\n    }\n    const onFinish = stats => {\n      if(this.state.stats.has(repo)) {\n        this.state.stats.set(repo, stats)\n        this.state.ready.set(repo, true)\n        this.setState({ stats: this.state.stats, ready: this.state.ready})\n      }\n      if (this._getAllProgress() === 100) {\n        this.setState({ loading: false })\n      }\n    }\n    const onProgress = progress => {\n      if(this.state.progress.has(repo)) {\n        this.state.progress.set(repo,progress)\n        this.setState({\n          progress:this.state.progress\n        })\n      }\n    }\n    const shouldAbort = () => {\n      // if (this._getAllProgress() === 100) {\n      //   this.setState({ loading: false })\n      // }\n      return !repos.includes(repo)\n    }\n\n    this.fetchCall(\n      owner, name,\n      onUpdate,\n      onFinish,\n      onProgress,\n      shouldAbort,\n    )\n\n    return 'FETCH REQUESTED'\n  }\n\n  /**\n   * get progress of fetching all\n   * @returns progress as number from 0 to 100\n   */\n  _getAllProgress = () => {\n    const { progress } = this.state\n    return Math.floor(Array.from(progress.values()).reduce((a, b) => a + b, 0)/ (progress.size === 0 ? 1 : progress.size))\n  }\n\n  _renderUpdateAllButton = () => {\n    const { loading, ready } = this.state\n    const { repos } = this.props\n\n    return (\n      <Button\n        icon=\"cloud-download\"\n        type=\"link\"\n        disabled={repos.length === 0}\n        onClick={() => {\n          this.setState({ loading: true })\n          if (this._getAllProgress() === 100) { // re-fetch all\n            repos.forEach(repo => this._fetch(repo))\n          }\n          else { // on fetch unfetched\n            repos.forEach(repo => {\n              if (!ready.get(repo)) {\n                this._fetch(repo)\n              }\n            })\n          }\n        }}\n        loading={loading}\n      >\n        update\n      </Button>\n    )\n  }\n\n  _renderRepoTags = () => {\n    const { progress, visible } = this.state\n    const { repos } = this.props\n\n    return (\n      repos.map(repo => (\n        <div key={\"section-tag\" + repo} style={{ display: 'inline-block'}}>\n          <Progress\n            type=\"circle\"\n            percent={progress.get(repo)}\n            showInfo={false}\n            strokeWidth={8}\n            width={16}\n          />\n          <Tag\n            className=\"repo-tag\"\n            checked={visible.get(repo)}\n            onChange={checked => {\n              visible.set(repo, checked)\n              this.setState({ visible })\n            }}\n          >\n            {repo}\n          </Tag>\n        </div>\n      ))\n    )\n  }\n\n  _renderBody = () => {\n    const { data, stats, ready, loading, type } = this.state\n    return <this.body data={data} stats={stats} min_height={this.refs.min_height} ready={ready} loading={loading} {...this.props}/>\n  }\n\n  render() {\n    const { type,chart } = this.props\n    const chartStyle = {\n      width: '50%', display: 'inline-block', height: '49vh'\n    }\n    return (\n      <div id={type} ref=\"min_height\" style={chart==1?chartStyle:null}>\n        <Row type=\"flex\" align=\"middle\" className=\"section-header\">\n          <div className=\"data-card\">\n            {this.icon}\n            <div className=\"section-title\">\n              {type}\n            </div>\n            {this.info ?\n              <Popover className=\"info-tag\" content={this.info} placement=\"left\">\n                <Icon type=\"info-circle\" />\n              </Popover> : null }\n          </div>\n          {chart != 1 && <div className=\"data-card\" style={{ marginLeft: 'auto' }}>\n            {this._renderRepoTags()}\n          </div>}\n          <Progress\n            type=\"circle\"\n            strokeWidth={4}\n            width={32}\n            percent={this._getAllProgress()}\n          />\n          <div className=\"data-card\">\n            {this._renderUpdateAllButton()}\n          </div>\n        </Row>\n        {this._renderBody()}\n      </div>\n    )\n  }\n\n}\n\nDataSection.propTypes = {\n  githubApiToken: PropTypes.string,\n  repos: PropTypes.array,\n  deleteRepo: PropTypes.string,\n  type: PropTypes.string,\n}\n\nconst mapStateToProps = state => ({\n  githubApiToken: state.github.githubApiToken\n})\n\nexport default connect(\n  mapStateToProps,\n)(DataSection)","import React from 'react'\nimport { connect } from 'react-redux'\nimport PropTypes from 'prop-types'\nimport _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport COLORS from './sections/Colors'\n\nimport { Row, Col, Anchor, Button, Tag, Tooltip, message, Select } from 'antd'\n\nimport DataSection from './DataSection'\n\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport { updateState } from '../actions'\nimport logo from '../image/logo.png'\n// const CENTER_FLEX = { display: 'flex', placeContent: 'center' }\n// const CENTER_LEFT_FLEX = { display: 'flex', justifyContent: 'flex-start', alignContent: 'center'}\n\n// message.config({\n//   top: 60,\n//   duration: 2,\n//   maxCount: 5,\n// })\n\nclass GithubStatistics extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      repos:[],\n      input: undefined,\n      suggestions: [],\n      testingRepo: false,\n      deleteRepo: '',\n    }\n\n    this.fetcher = new GithubFetcher('05c1acf261f6b223411c73d8b71cb1a30ce9186a')\n\n    this.props.updateState(\"githubApiToken\", '05c1acf261f6b223411c73d8b71cb1a30ce9186a')\n\n    this.search = _.debounce(\n      this.fetcher.searchRepository,\n      300,\n      { leading: false, trailing: true }\n    ).bind(this)\n  }\n  componentWillMount() {\n    if (this.GetRequest().chart == 1) {\n      localStorage.setItem(\"repos\", JSON.stringify(['vesoft-inc/nebula']))      \n    }\n  }\n\n  componentDidMount() {\n    try {\n      if (JSON.parse(localStorage.getItem(\"repos\"))) {\n        this.setState({\n          repos: JSON.parse(localStorage.getItem(\"repos\")),\n          deleteRepo: '',\n        })\n      }\n    } catch (error) {\n      console.log(error)\n    }\n  }\n  GetRequest() {\n    let url = window.location.search\n    let theRequest = new Object();\n    if (url.indexOf(\"?\") != -1) {\n    let arr = url.substr(1).split(\"&\")\n      for (var i = 0; i < arr.length; i++) {\n        theRequest[arr[i].split(\"=\")[0]] = arr[i].split(\"=\")[1];\n      }\n    } else {\n      theRequest['chart']  = 0;\n    }\n    return theRequest;\n  }\n\n\n  deleteRepo = index => {\n    const { repos } = this.state\n    const deleteRepo = repos[index]\n    repos.splice(index, 1)\n    this.setState({\n      repos: [...repos],\n      deleteRepo: deleteRepo,\n    }, () => {\n      localStorage.setItem(\"repos\", JSON.stringify([...repos]))\n    })\n  }\n\n  addRepo = repo => {\n    const { repos } = this.state\n    if (repos.includes(repo)) {\n      message.error(`${repo} is already added`)\n    }else {\n      this.setState({\n        repos: [ ...repos, repo],\n        deleteRepo: '',\n      }, () => {\n        localStorage.setItem(\"repos\", JSON.stringify([...repos, repo]))\n      })\n    }\n  }\n\n  // _handleAdding = repo => {\n  //   const slashIndex = repo.indexOf('/')\n  //   const owner = repo.slice(0, slashIndex)\n  //   const name = repo.slice(slashIndex + 1)\n\n  //   this.setState({ testingRepo: true })\n  //   this.fetcher.testRepository(owner, name,\n  //     result => {\n  //       this.setState({ testingRepo: false })\n  //       if (result) {\n  //         this.addRepo(repo)\n  //         message.success(repo + ' added')\n  //       } else {\n  //         message.error('Repository not found')\n  //       }\n  //     }\n  //   )\n  // }\n\n  _renderTags = () => {\n    const { repos } = this.state\n\n    return (\n      repos.map((repo, index) => (\n        <Tag key={\"tag\" + repo} color={COLORS[index]} closable onClose={() => this.deleteRepo(index)}>\n          <a target=\"_blank\" rel=\"noopener noreferrer\" href={`https://github.com/${repo}`}>{repo}</a>\n        </Tag>\n      ))\n    )\n  }\n\n  _renderHeaderInput = () => {\n    const { repos, input, testingRepo, suggestions } = this.state\n\n    // const format = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/{1}[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i\n    let hintMessage = ''\n\n    // Conditions\n    const inputEmpty = input === undefined\n    // const formatIncorrect = !format.test(input)\n    const repoExisted = repos.includes(input)\n\n    if (repoExisted) hintMessage = 'Repository already added'\n    // if (formatIncorrect) hintMessage = 'Input incorrectly formatted'\n    if (inputEmpty) hintMessage = 'Empty'\n\n    const disabled = inputEmpty || repoExisted\n\n    return (\n      <React.Fragment>\n        {/* <Input\n          className=\"header-input\"\n          prefix={<Icon type=\"github\"/>}\n          placeholder=\"owner/name\"\n          value={input}\n          onChange={e => {\n            this.setState({ input: e.target.value })\n            this.fetcher.searchRepository(e.target.value, suggestions => this.setState({ suggestions }))\n          }}\n          onPressEnter={() => !disabled && this._handleAdding(input)}\n          disabled={testingRepo}\n          allowClear\n        /> */}\n        <Select\n          className=\"header-input\"\n          value={input}\n          placeholder=\"search by repository\"\n          defaultActiveFirstOption={false}\n          onChange={input => {\n            this.setState({ input })\n            this.addRepo(input)\n          }}\n          onSearch={input => this.search(input, suggestions => this.setState({ suggestions }))}\n          notFoundContent={null}\n          showArrow={false}\n          filterOption={false}\n          showSearch\n        >\n          {suggestions.map(repo => (\n            <Select.Option key={`suggestion-${repo}`} value={repo}>{repo}</Select.Option>\n          ))}\n        </Select>\n        <Tooltip\n          title={hintMessage}\n        >\n          <Button\n            icon=\"plus\"\n            type=\"primary\"\n            loading={testingRepo}\n            disabled={disabled}\n            onClick={() => this.addRepo(input)}\n          />\n        </Tooltip>\n      </React.Fragment>\n    )\n  }\n\n  render() {\n    // const dotStyle = {strokeWidth: 2, r: 2.5}\n    const { repos, deleteRepo } = this.state\n    return (\n      <React.Fragment>\n        {this.GetRequest().chart!=1 && \n      <div>\n        <header className=\"header\">\n          <Row type=\"flex\" align=\"middle\">\n            <Col className=\"header-section\">\n              <a className=\"header-title\" href=\"https://github.com/vesoft-inc/github-statistics\" target=\"_blank\">\n                GitHub Stats\n              </a>\n            </Col>\n            <iframe src=\"https://ghbtns.com/github-btn.html?user=vesoft-inc&repo=github-statistics&type=star&count=true\" frameBorder=\"0\" scrolling=\"0\" width=\"100px\" height=\"20px\" />\n            <Col className=\"header-section flex-center\">\n              {this._renderHeaderInput()}\n            </Col>\n            <Col className=\"header-section flex-center-left\">\n              {this._renderTags()}\n            </Col>\n          </Row>\n          <a href=\"https://vesoft.com/\" target=\"_blank\">\n            <img src={logo} alt=\"\" className=\"header-logo\" />\n          </a>\n        </header>\n        <div className=\"container\">\n          <div className=\"sider\">\n            <Anchor bounds={0} className=\"anchor\" offsetTop={70}>\n              {Object.values(TYPES).map(value => (\n                <Anchor.Link key={`anchor-link-${value}`} title={value} href={`#${value}`}/>\n              ))}\n            </Anchor>\n          </div>\n          <div className=\"content\" >\n            <DataSection\n              type={TYPES.REPO}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.STAR}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.FORK}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.COMMIT}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.RELEASE}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n            <DataSection\n              type={TYPES.ISSUES}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n            <DataSection\n              type={TYPES.PULLREQUESTS}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n          </div>\n        </div>\n\n        <footer className=\"footer\">\n        </footer>\n          </div>}\n        {\n          this.GetRequest().chart == 1 && <div style={{ width:'100%',height:'100vh',padding:'0 3% 0'}}>\n            <DataSection\n              type={TYPES.STAR}\n              repos={repos}\n              chart={this.GetRequest().chart}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.FORK}\n              repos={repos}\n              chart={this.GetRequest().chart}\n              deleteRepo={deleteRepo}\n            />\n            <br/>\n            <DataSection\n              type={TYPES.COMMIT}\n              chart={this.GetRequest().chart}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n            <DataSection\n              type={TYPES.PULLREQUESTS}\n              chart={this.GetRequest().chart}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n          </div>\n        }\n      </React.Fragment>\n    )\n  }\n}\n\nGithubStatistics.propTypes = {\n  updateState: PropTypes.func,\n}\n\nconst mapDispatchToProps = dispatch => ({\n  updateState: (state, data) => dispatch(updateState(state, data)),\n})\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(GithubStatistics)","export const updateState = (state, data) => ({\n  type: 'UPDATE_STATE',\n  payload: { state, data }\n})\n\nexport const updateStatsField = (state, stats) => ({\n  type: 'UPDATE_STATS_FIELD',\n  payload: { state, stats }\n})","import React from 'react'\nimport GithubStatistics from './GithubStatistics'\nimport '../css/App.css'\nconst chart =function isChart () {\n  let url = window.location.search\n  let theRequest = new Object()\n  if (url.indexOf(\"?\") != -1) {\n    let arr = url.substr(1).split(\"&\")\n    for (var i = 0; i < arr.length; i++) {\n      theRequest[arr[i].split(\"=\")[0]] = arr[i].split(\"=\")[1]\n    }\n  } else {\n    theRequest['chart'] = 0\n  }\n  return theRequest.chart\n}\nchart() == 1 ? import('../css/default.css') :import ('../css/App.css')\nclass App extends React.Component {\n\n  render() {\n    return (\n      <div>\n        <GithubStatistics />\n      </div>\n    )\n  }\n}\n\n\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport reducers from './reducers'\n\nimport './css/normalize.css'\nimport './css/index.css'\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\n\nconst store = createStore(reducers)\nReactDOM.render(\n  <React.Fragment>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.Fragment>\n  ,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}